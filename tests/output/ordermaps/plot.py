# Compact script for plotting ordermaps generated by `gorder`. License is MIT.
# Run using `uv`: `uv run plot.py INPUT_ORDERMAP` or `uv run plot.py INPUT_ORDERMAP OUTPUT_PNG`.
# /// script
# requires-python = ">=3.10"
# dependencies = ["numpy>=2.2.1", "matplotlib>=3.10.0", "pyqt5>=5.15.11", "rich>=13.9.4"]
# ///

import numpy as np, matplotlib.pyplot as plt, argparse, threading, itertools, time
from matplotlib.colors import Normalize, TwoSlopeNorm
from rich import print

def spinner(stop_event, input):
    for c in itertools.cycle("|/-\\"):
        if stop_event.is_set(): break
        print(f"Plotting `[cyan]{input}[/cyan]` {c}", end="\r", flush=True)
        time.sleep(0.1)
    print(" " * 50, end="\r")

def main():
    p = argparse.ArgumentParser()
    p.add_argument("input"), p.add_argument("output", nargs="?")
    a = p.parse_args()
    stop_event = threading.Event()
    spin_thread = threading.Thread(target=spinner, args=(stop_event, a.input))
    spin_thread.start()

    try:
        x, y, z, xr, yr, zr, cm, zmin, zmax, zstep, xmin, xmax, xstep, ymin, ymax, ystep = [], [], [], None, None, None, "seismic_r", None, None, None, None, None, None, None, None, None

        with open(a.input) as f:
            for l in f:
                if l.startswith("#") or not l.strip(): continue
                if l.startswith("@"):
                    if "xlabel" in l: xr = l.split("xlabel")[1].strip()
                    if "ylabel" in l: yr = l.split("ylabel")[1].strip()
                    if "zlabel" in l: zr = l.split("zlabel")[1].strip()
                    if "zrange" in l: zmin, zmax, *zstep = map(float, l.split("zrange")[1].split())
                    if "xrange" in l: xmin, xmax, *xstep = map(float, l.split("xrange")[1].split())
                    if "yrange" in l: ymin, ymax, *ystep = map(float, l.split("yrange")[1].split())
                    continue
                if l.startswith("$"): 
                    if "colormap" in l: cm = l.split()[-1].strip()
                    continue
                x.append(float(l.split()[0])), y.append(float(l.split()[1])), z.append(float(l.split()[2]) if l.split()[2].lower() != "nan" else np.nan)

        diverging_cmaps = {'PiYG', 'PRGn', 'BrBG', 'PuOr', 'RdGy', 'RdBu', 'RdYlBu', 'RdYlGn', 'Spectral', 'coolwarm', 'bwr', 'seismic', 'berlin', 'managua', 'vanimo'}
        x, y, z = np.array(x), np.array(y), np.array(z)
        xi, yi = np.unique(x), np.unique(y)
        zi = np.full((len(xi), len(yi)), np.nan)
        for xv, yv, zv in zip(x, y, z): zi[np.where(xi == xv)[0][0], np.where(yi == yv)[0][0]] = zv
        xi, yi = np.meshgrid(xi, yi)

        if cm.rstrip("_r") in diverging_cmaps and zmin is not None and zmax is not None and zmin < 0 < zmax:
            norm = TwoSlopeNorm(vmin=zmin, vcenter=0, vmax=zmax)
        else:
            norm = Normalize(vmin=zmin if zmin is not None else np.nanmin(z), vmax=zmax if zmax is not None else np.nanmax(z))

        plt.contourf(xi, yi, zi.T, levels=np.linspace(zmin if zmin is not None else np.nanmin(z), zmax if zmax is not None else np.nanmax(z), 500), cmap=cm, norm=norm)
        zstep = zstep[0] if zstep else ((zmax - zmin) / 5 if zmax is not None and zmin is not None else 1)
        cbar = plt.colorbar(ticks = np.arange(zmin if zmin is not None else np.nanmin(z), (zmax if zmax is not None else np.nanmax(z)) + zstep, zstep))
        cbar.set_label(zr)
        plt.xlabel(xr), plt.ylabel(yr)
        if xmin is not None and xmax is not None: plt.xticks(np.arange(xmin, xmax + (xstep[0] if xstep else (xmax-xmin)/10), xstep[0] if xstep else (xmax-xmin)/10)), plt.xlim([xmin, xmax])
        if ymin is not None and ymax is not None: plt.yticks(np.arange(ymin, ymax + (ystep[0] if ystep else (ymax-ymin)/10), ystep[0] if ystep else (ymax-ymin)/10)), plt.ylim([ymin, ymax])
        plt.tight_layout()

        if a.output: plt.savefig(a.output, dpi=300); stop_event.set(); spin_thread.join(); print(f"Plotting `[cyan]{a.input}[/cyan]` [bold green]✔[/bold green]"); print(f"Saved plot to `[cyan]{a.output}[/cyan]`")
        else: stop_event.set(); spin_thread.join(); print(f"Plotting `[cyan]{a.input}[/cyan]` [bold green]✔[/bold green]"); plt.show()

    except Exception as e:
        stop_event.set()
        spin_thread.join()
        print(f"[bold red]error:[/bold red] {e}")
        return

if __name__ == "__main__": main()